# Experiment 4: Disjunctive Conditional Pathways (Short Props, Delayed)

## üéØ PBTL Property

`EP( (EP(s1) & !EP(j1)) | (EP(j2) & ms & !EP(s2)) )`

* **Property Explanation (using short prop names from trace):**
    * `s1`: Prerequisite/Step 1 for Branch 1 is achieved.
    * `j1`: Interference/Negative condition for Branch 1 has occurred.
    * `j2`: Prerequisite/Step 1 for Branch 2 is achieved.
    * `ms`: A mandatory simultaneous state/action for Branch 2.
    * `s2`: Interference/Negative condition for Branch 2 has occurred.
* **Type**: This is a disjunction (`|`).
    * **Branch 1 (`EP(s1) & !EP(j1)`)**: A P+N type (P-block `EP(s1)`, N-block `!EP(j1)`).
    * **Branch 2 (`EP(j2) & ms & !EP(s2)`)**: A P+M+N type (P-block `EP(j2)`, M-literal `ms`, N-block `!EP(s2)`).
* **Goal**: The property is satisfied if there exists a past global state (frontier) where the conditions for *either* Branch 1 OR Branch 2 are met from the perspective of that frontier.
    * **Branch 1 True**: `s1` has held in the past, AND `j1` has *not* held in the past (up to or at that point).
    * **Branch 2 True**: `j2` has held in the past, AND `ms` is currently true on the frontier, AND `s2` has *not* held in the past (up to or at that point).
* **Interpretation**: The system can reach a valid state through one of two complex pathways. Each pathway has positive conditions (some past, some current like `ms`) and negative conditions that must not have occurred.

---

## ‚öôÔ∏è Trace Generation (`experiment4_trace_generator.py`)

This script generates a CSV trace file for the property above, using short proposition names and aiming to delay any conclusive verdict.

### Processes and Roles:

* **S1**: Source process for proposition `s1`.
* **J1**: Source process for proposition `j1` (interfering with Branch 1).
* **J2**: Source process for proposition `j2`.
* **MS**: Source process for proposition `ms` (works in conjunction with `j2`).
* **S2**: Source process for proposition `s2` (interfering with Branch 2).
* **PO (Observer)**: "Observes" the other processes via shared communication events. The property's satisfaction is evaluated from PO's perspective.

### Trace Construction and "Delayed Conclusion" Logic:

The trace generation aims for the `--size` total number of events and uses phases to make an early conclusive verdict less likely.

1.  **Short Proposition Names Used**:
    * Key props: `s1`, `j1`, `j2`, `ms`, `s2`.
    * Dormant props: `dS1`, `dJ1`, `dJ2`, `dMS`, `dS2` (used in the initial phase).
    * Communication markers: `cS1PO`, `cJ1PO`, `cJ2PO`, `cMSPO`, `cS2PO`.
    * PO "knows" props: `kS1`, `kJ1` (knows `j1` occurred), `kJ2`, `kMS`, `kS2` (knows `s2` occurred).
    * PO evaluation marker: `poe`.

2.  **Phased Generation & Orchestration**:
    * **Dormant Phase (e.g., first ~50-60% of events)**:
        * Source processes (S1, J1, J2, MS, S2) generate their "dormant" props (e.g., `dS1`) instead of the key props. Probabilities for key props are effectively zero.
        * Communication to PO, if it happens (low probability), transfers only these dormant states.
        * This makes it impossible for PO to satisfy either branch of the disjunction.
    * **Active Phase (remaining events)**:
        * Key props (`s1, j1, j2, ms, s2`) begin to be generated by their source processes with moderate, randomized probabilities.
        * Communication of these states to PO also happens with moderate probability.
    * **Orchestrated Conclusive Cycle (a single logical cycle, targeted very late in the Active Phase, if trace is long enough)**:
        * The generator randomly chooses to target *either* Branch 1 or Branch 2 for likely satisfaction.
        * **If targeting Branch 1 (`EP(s1) & !EP(j1)`)**:
            * S1: High probability of `s1` occurring and being communicated to PO.
            * J1: Very low probability of `j1` occurring, OR if it does, very low probability of PO learning about `j1`.
            * Activity/communication for Branch 2 conditions (`j2, ms, s2`) is suppressed.
        * **If targeting Branch 2 (`EP(j2) & ms & !EP(s2)`)**:
            * J2: High probability of `j2` occurring and being communicated to PO.
            * MS: (After PO is likely to know `j2`) High probability of `ms` occurring and being communicated to PO.
            * S2: Very low probability of `s2` occurring, OR if it occurs, very low probability of PO learning about `s2`.
            * Activity/communication for Branch 1 conditions (`s1, j1`) is suppressed.
        * This provides a focused (but still not 100% guaranteed) attempt to satisfy one branch late in the trace.
    * Outside this single orchestrated cycle, the alignment of conditions for either branch is less probable.

3.  **Logical Action Cycle**: Events are generated by cycling through actions like `S1_internal`, `J1_internal`, ..., `S1_PO_comm`, ..., `PO_evaluate`.
4.  **Shared Communication Events**: When communication with PO occurs, it's a shared event (e.g., `processes: S1|PO`). Both processes increment their clocks, merge VCs, and adopt the merged VC. PO "learns" the state of the sender.
5.  **PO's Evaluation**: The `PO_evaluate` event marks a point where PO has gathered some information. Its props (like `kS1`, `k_not_j1`) reflect its current understanding based on communications within that logical cycle.
6.  **Total Event Count**: The script generates the exact number of events specified by `--size`.

This approach aims to create traces that are mostly `INCONCLUSIVE` for a long duration, with a specific, targeted attempt to achieve a `TRUE` state for one of the property's main branches towards the end.