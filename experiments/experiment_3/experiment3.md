# Experiment 3: Conditional Action Outcome (Short Props, Delayed Conclusion)

## ðŸŽ¯ PBTL Property

`EP( (aX & EP(pX)) | (aY & EP(pY)) )`

* **Property Explanation (using short prop names from trace):**
    * `pX`: Prerequisite for action X is met.
    * `aX`: Action X is taken.
    * `pY`: Prerequisite for action Y is met.
    * `aY`: Action Y is taken.
* **Type**: This property involves a disjunction (`|`). Each branch of the disjunction is a conjunction (`&`) of a current state literal (e.g., `aX`) and a past condition (`EP(pX)`).
* **Goal**: The property is satisfied if there exists at least one global state (frontier) in the past where *either*:
    1.  `aX` was true AND `pX` had occurred at or before that point.
    2.  OR `aY` was true AND `pY` had occurred at or before that point.
* **Interpretation**: This models a system where a successful outcome can be achieved via one of two alternative pathways (Pathway X or Pathway Y). Each pathway requires its main action (`aX` or `aY`) to be taken only after its corresponding prerequisite (`pX` or `pY`) has already been fulfilled in the system's history, as observed from the satisfying state.

---

## âš™ï¸ Trace Generation (`experiment3_trace_generator.py`)

This script generates a CSV trace file for the property above, using short proposition names. It's designed to make the satisfaction of the property (if it occurs) happen towards the middle or end of the trace, rather than immediately.

### Processes and Roles:

* **PX (Process X)**: Handles Pathway X.
    * May generate `pX` (prerequisite X met) and then `aX` (action X taken).
* **PY (Process Y)**: Handles Pathway Y.
    * May generate `pY` (prerequisite Y met) and then `aY` (action Y taken).
* **PV (Verifier/Observer)**: "Observes" PX and PY through shared communication events. The property's evaluation is from PV's perspective (i.e., based on information PV has causally learned).

### Trace Construction and "Delayed Conclusion" Logic:

The `--size` parameter controls the total number of events. The trace generation employs phases to delay when the property might become conclusively TRUE:

1.  **Short Proposition Names Used**:
    * `pX`, `aX`, `pY`, `aY`: Core propositions for the property.
    * `dX`, `dY`: "Dormant" or placeholder pings from PX and PY during the initial, less active phase.
    * `cXP`, `cYP`: Indicate shared communication events (e.g., `cXP` for PX to PV).
    * `kvpX`, `kvaX`, `kvpY`, `kvaY`: Propositions on PV's events, reflecting what PV "knows" about prerequisites and actions.
    * `pve`: Marks an evaluation or decision point for PV.

2.  **Phased Generation**:
    * **Dormant Phase (e.g., first ~50-60% of events, or a minimum number of cycles)**:
        * PX and PY generate `dX` and `dY` (dormant props) instead of the key props `pX, aX, pY, aY`.
        * Probabilities for these key props occurring at source are effectively zero.
        * Communication of (dormant) states to PV occurs with low probability.
        * This phase makes it virtually impossible for PV to learn the conditions for property satisfaction.
    * **Active Phase (remaining events)**:
        * PX and PY begin to generate their actual key props (`pX`, `aX`, `pY`, `aY`) with moderate, randomized probabilities. The logic ensures an action (`aX`/`aY`) is only generated if its prerequisite (`pX`/`pY`) was set in that process's immediately preceding internal state for the current logical cycle.
        * Communication of these states to PV also occurs with moderate, randomized probabilities.
    * **Orchestrated Conclusive Cycle (a single logical cycle, late in the Active Phase)**:
        * If the trace is long enough, the generator targets one specific cycle of actions (PX_prereq -> PX_action -> ... -> PV_evaluate) to have a high chance of satisfying *one* of the disjunct's branches.
        * It randomly picks either "Pathway X" or "Pathway Y" to orchestrate.
        * For the chosen pathway (e.g., X): Probabilities for `pX` occurring, then `aX` occurring, and PX successfully communicating this to PV, are set very high.
        * For the *other* pathway (e.g., Y): Probabilities for its conditions or communication are suppressed during this orchestrated cycle.
        * This provides a strong (but not guaranteed) attempt to make the property TRUE late in the trace.
    * Outside this single orchestrated cycle, even within the active phase, the alignment of all necessary conditions for either branch is less likely due to general randomness.

3.  **Logical Action Cycle**: Events are generated by cycling through actions like `PX_prereq_internal`, `PX_action_internal`, `PY_prereq_internal`, `PY_action_internal`, `PX_PV_comm`, `PY_PV_comm`, `PV_evaluate`.
4.  **Shared Communication Events**: When communication occurs (e.g., PX with PV), it's a shared event (e.g., `processes: PX|PV`). Both involved processes increment their local clock components, and then their full internal vector clocks are updated to be the component-wise maximum of their two clocks. This merged VC is recorded for the shared event. PV learns the state of the other process as of its last internal event.
5.  **Total Event Count**: The main loop generates exactly the number of events specified by `--size`. Probabilistic skipping of actions (like communication) is handled such that the target event count is still met by actual generated events.

This design aims to produce traces where the property stays `INCONCLUSIVE` for a substantial initial period, then enters a phase with general random activity where satisfaction is possible but not forced, and includes a specific late attempt to satisfy one of the conditions for a `TRUE` verdict.